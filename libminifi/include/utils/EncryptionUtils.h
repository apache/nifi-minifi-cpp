/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#pragma once

#include <string>
#include <vector>

struct evp_aead_st;
typedef struct evp_aead_st EVP_AEAD;

namespace org {
namespace apache {
namespace nifi {
namespace minifi {
namespace utils {
namespace crypto {

using Bytes = std::vector<unsigned char>;

Bytes stringToBytes(const std::string& text);

std::string bytesToString(const Bytes& bytes);

Bytes randomBytes(size_t num_bytes);

struct EncryptionType {
  static const EVP_AEAD* cipher();
  static std::string name();
  static size_t nonceLength();
};

/**
 * Encrypt the input using an AEAD (authenticated encryption with additional data).
 *
 * Uses the XChaCha20 stream cipher with the Poly1305 MAC (message authentication code).
 * Takes the plaintext as input, and returns the ciphertext (encrypted plaintext) plus the tag, concatenated.
 * The ciphertext has the same length as the plaintext, and the tag is always 16 bytes long, so the output
 * is 16 bytes longer than the input.
 *
 * @param input plaintext
 * @param aad additional data, not encrypted, but included when computing the tag, for authentication
 * @param key secret key; 32 bytes (256 bits), should be generated by a CSPRNG
 * @param nonce random data freshly generated for each encryption to break rainbow table-type attacks;
 *              not encrypted and not secret, but included when computing the ciphertext;
 *              24 bytes (192 bits), should be generated by a CSPRNG
 * @return ciphertext + tag
 * @throws std::exception if the encryption fails
 */
std::string aeadEncrypt(const std::string& input, const std::string& aad,
                        const Bytes& key, const Bytes& nonce);

/**
 * Encrypt the plaintext using a randomly-generated nonce.
 *
 * Same as aeadEncrypt(), but generates the nonce randomly, and prepends it to the output.
 */
std::string encrypt(const std::string& plaintext, const std::string& aad, const Bytes& key);

/**
 * Decrypt the input using an AEAD (authenticated encryption with additional data).
 *
 * Uses the XChaCha20 stream cipher with the Poly1305 MAC (message authentication code).
 * Takes the ciphertext + tag as input, and returns the plaintext, and also authenticates the ciphertext by
 * checking that the `aad` argument matches the `aad` that was given during the encryption.
 * The plaintext has the same length as the ciphertext, and the tag is always 16 bytes long, so the output
 * is 16 bytes shorter than the input.
 *
 * @param input ciphertext + tag
 * @param aad additional data used to authenticate the input, must be the same as used when encrypting
 * @param key secret key; 32 bytes (256 bits), must be the same as used when encrypting
 * @param nonce random data freshly generated for each encryption to break rainbow table-type attacks;
 *              24 bytes (192 bits), must be the same as used when encrypting
 * @return plaintext
 * @throws std::exception if either the decryption or the authentication fails
 */
std::string aeadDecrypt(const std::string& input, const std::string& aad,
                        const Bytes& key, const Bytes& nonce);

/**
 * Decrypt an input of the form nonce + ciphertext + tag.
 *
 * Same as aeadDecrypt(), but takes the nonce from the start of the input.
 */
std::string decrypt(const std::string& input, const std::string& aad, const Bytes& key);

}  // namespace crypto
}  // namespace utils
}  // namespace minifi
}  // namespace nifi
}  // namespace apache
}  // namespace org
